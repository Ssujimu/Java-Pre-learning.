상속 (inheritance)
 - 다른 클래스로 부터 상속받아 그 클래스의 기능(메소드)과 속성(변수, 상수)을 사용하는 것
 	단, 소스의 재활용적인 측면으로만 상속을 사용하면 안됨
	상위클래스에서 하위클래스의 멤버에 접근할 수는 없음

 - 자바의 모든 클래스(Object 클래스 제외)는 이미 상속 받고 있음
 	Object는 모든 자바의 클래스들이 상속받는 최상위 클래스임

 - 자바에서는 단일 상속만을 지원하기 때문에 하나의 클래스에서만 상속받을 수 있음(C언어는 다중상속 지원)

 - 자바에서의 상속은 상위 클래스와 동일한 성격을 지닌 클래스로 생성하기 위해 상속을 사용함
 	상속받은 클래스를 '하위클래스'또는 '서브(sub)클래스'라 하고, 상속을 해준 클래스를 '상위클래스' 또는 '슈퍼(super) 클래스'라 함

 - 하위클래스의 생성자에서는 반드시 상위클래스의 생성자를 호출해야 함, 첫 줄에 해야 함
 	생략하면 JVM이 자동으로 인수없는 기본 생성자를 호출함
	super 키워드를 이용하여 상위 클래스의 생성자를 호출(매개변수가 있으면 그 값도 넣어줘야 함)

 - private으로 선언된 멤버도 상속은 되지만 직접적인 접근은 불가(protected 메소드를 통해 접근해야 함)

 - 문법
class 하위 클래스면 extends 상위클래스명 {
	하위클래스 생성자() {
		super();	// 상위클래스의 생성자를 호출하는 것으로 반드시 하위클래스 생성자의 첫 줄에 있어야 함
	}
}


상속을 하기 위한 클래스간의 관계
 - 기본적으로 모든 클래스(final 제외)를 상속받을 수 있으나 특정 관계가 성립하는 클래스들끼리 상속을 해야 자바에서의 상속 목적에 맞음
 - is-a 관계
 	'하위클래스 is a 상위 클래스'의 관계가 성립되는 클래스들을 의미
	즉, 하위클래스가 상위클래스의 일종으로 사용되는 경우를 의미
 - has-a 관계
 	'하위클래스 has a 상위클래스'의 관계가 성립되는 클래스들을 의미
	하위클래스가 상위클래스를 소유하고 있는 경우를 의미
	단, 소유하지 않는 경우가 있을 경우 상속은 다시 생각해봐야 함(예외적인 상황이 있을 경우 상속을 받지 않는 것이 좋음)
	만약 소유하지 않는 경우가 있는데도 상속을 하면 소유하지 않는 인스턴스는 표현이 안됨
	소유하지 않는 경우가 있는 has-a 관계는 상속이 아닌 복합방식으로 처리해야 함

※ null : 빈 값을 의미하는 것으로 객체가 비었을 때 들어가는 아무것도 아닌 값
 - 객체가 비어있는 것을 의미하는 값으로 if문 등에서 조건으로 사용할 수 있음
 - 조건으로 사용시 비교를 연산자인 '=='로 비교할 수 있음
	예) 객체 == null -> 객체가 비었는지 여부를 검사


오버라이딩(Overriding)
 - 하위클래스에서 상위 클래스의 메소드를 재정의하는 것
 	오버로딩과 다르게 선언부(리턴타입, 메소드명, 매개변수)가 완전히 동일함
 - 오버라이딩시 접근 제어지시자는 반드시 원본보다 넓거나 최소 같은 범위를 사용해야 함
 	원본이 public이면 오버라이딩 되는 메소드는 무조건 public으로 선언해야 함
 - 하위클래스의 인스턴스로 오버라이딩된 메소드를 호출하면 무조건 하위클래스의 메소드가 실행됨
 	하위클래스의 인스턴스로는 상위클래스의 오버라이딩 원본 메소드를 호출할 수 없음
	상위클래스의 오버라이딩 원본 메소드를 호출하려면 하위클래스인 오버라이딩 메소드에서 super 키워드로 호출해야 함
	예) super.원본메소드명();

※ 상위클래스로 선언된 인스턴스에는 하위클래스의 인스턴스가 저장될 수 있음
 - 그 인스턴스는 알맹이는 하위클래스 이지만 JVM에게는 상위 클래스로 인식됨
 	그러므로 실제 사용할 수 있는 멤버는 상위클래스에 있는 멤버들만 가능
 - 이 상황에서 하위클래스의 메소드를 사용하는 방법
 	1. 오버라이딩 - 필요한 메소드를 상위클래스에도 정의하여 하위클래스에서 오버라이딩하게 하여 사용
	 - 단, 상위클래스를 변경할 수 있으며, 변경해도 괜찮은 경우에만 사용가능
	2. 형변환 - 해당 하위클래스로 형변환한 후 사용 : java API에서 제공하거나 변경하면 안되는 상위클래스일 경우


instanceof 연산자
 - 인스턴스가 지정한 특정 클래스로 형변환이 가능한지 여부를 검사하는 연산자
 	절대 실제 자료형을 묻는 연산자는 아님
 - 상속관계를 바탕으로 형변환 가능여부를 물음
 	예) a instanceof Bb -> a인스턴스가 Bb 클래스형으로 형변환이 가능한지 여부


Object 클래스
 - java.lang.Object 클래스는 모든 자바의 클래스들이 상속받고 있는 최상위 클래스
	extends Object 명령은 모든 클래스에서 생략되어 있을 뿐 Object 클래스를 상속받음
 - 모든 클래스는 Object 클래스의 하위클래스로 Object로 선언한 인스턴스에는 모든 종류의 인스턴스가 저장될 수 있음
 	인스턴스가 아닌 기본자료형 데이터들도 Wrapper클래스를 이용하면 인스턴스화 하여 사용할 수 있음
 - 모든 클래스에서는 Object 클래스의 멤버들을 자유롭게 사용할 수 있음 (예 : equals(), toString() 등)
 - 모든 클래스에서 오버라이딩 해놓으면 좋은 toString() 메소드 : Java API에서 권장하는 사항
 	String toString() : 객체(인스턴스)를 출력할 때 그 객체를 문자열로 변환시켜 리턴하는 메소드
	객체 출력시 자동으로 실행되는 메소드로 객체를 문자열로 변환시켜 출력하는데 그 값이 별 쓸모가 없으므로 원하는 형태의 문자열로 오버라이딩하여 바꿔주는 것이 좋다.
	주로 정보 저장용 클래스에서 많이 사용하며, 프로그래밍 시 확인(디버깅)용으로 사용될 수 있음


final 키워드
 - final 변수 : 해당 변수를 상수로 생성 - 값 변경 불가
	선언법 : final 자료형 변수명;
 - final 메소드 : 오버라이딩 불가
 	선언법 : 접근제어지시자 final 리턴타입 메소드명()
 - final 클래스 : 상속불가 - 상속받지 말고 인스턴스 생성해서 사용하라는 의미(주로 Java API에서 제공하는 클래스들 중에 있음)
 	선언법 : 접근제어지시자 final class 클래스명 {}


abstract 클래스
 - 추상(화) 클래스라고도 하는 클래스의 일종으로 미완성 클래스
 - 하나 이상의 abstract 메소드를 가지고 있는 클래스로 인스턴스 생성이 불가능함
 - 상속에서 상위클래스의 역할을 하기 위해 정의되는 클래스
 	abstract 클래스를 상속받은 하위클래스에서는 반드시 abstract 클래스의 abstract 메소드를 오버라이딩 하여 완성해야 함
	만약 abstract 메소드를 오버라이딩하지 않거나 완성하지 않으면 하위 클래스도 abstract로 선언해야 함
 - 단점 : 상속으로만 사용이 가능하므로 상속을 할 수 없는 상황에서는 사용불가
 - 선언 : abstract class 클래스명 {}

 - abstract 메소드
 	미완성된 메소드로 구현부(중괄호) 없이 선언부만 존재하는 메소드
	선언 : 접근제어지시자 abstract 리턴타입 메소드명();


interface
 - 모든 메소드가 abstract인 완전한 abstract 클래스를 interface로 지정할 수 있음
 	클래스는 아니나 클래스처럼 동작하기도 함
 - 자바에서 불가능한 다중 상속의 효과를 낼 수 있는 방법이기도 함
 - 상속의 extends 대신 구현의 implements 키워드를 사용하며 여러 개의 interface를 한 번에 사용할 수도 있음
 	클래스가 아님에도 같은 interface끼리는 상속이 가능
 - interface에서 선언하는 모든 메소드는 자동으로 public abstract 로 선언됨
 - interface에서 선언하는 모든 변수는 자동으로 public static final 로 선언됨
 	공용으로 사용할 상수 때문에 interface를 사용하기도 함


예외(exception)
 - 에러가 아닌 프로그램 실행중에 나타나는 예외적인 상황으로 컴파일은 되지만 실행시 특정 상황에서만 문제가 발생하는 경우
 - 개발자가 미리 알고 처리해야 하는 작업
 - 자바에서는 예외적인 상황의 처리를 위해 try-catch 제어문을 사용할 수 있음
 - 문법
try {
	예외가 발생하는지 검사할 실행문들;
} catch(발생할 예외 클래스 매개변수) {
	발생한 예외에 대한 처리문;
}
[ catch(발생할 예외 클래스 매개변수2) {
	발생한 예외에 대한 처리문2;
}
...
catch(발생할 예외 클래스 매개변수n) {
	발생한 예외에 대한 처리문n;
} finally {
	예외 발생과 상관없이 반드시 실행되는 영역
} ]
 - 하나의 try에 여러 개의 catch문을 사용할 수 있음
 - 단, 여러 catch문을 사용할 경우 반드시 상위클래스에 해당하는 예외는 아래쪽에 배치해야 함
 	예) Exception 클래스는 항상 가장 마지막 catch문에서 사용해야 함
 - finally : try나 catch문 중간에 return으로 메소드를 종료시켜도 실행되는 영역
 	예외 발생과 상관없이 반드시 실행되어야 하는 실행문을 입력하는 영역
	예) DB Connection 닫기, ResultSet 닫기 등의 기능을 주로 사용하는 영역
 - 메소드들 중 선언부에 'throws 예외클래스[, 다른예외클래스(들)]' 를 정의한 메소드들은 반드시 try-catch안에서 호출해야 함
 	일반적으로 DB관련 메소드들은 거의 대부분 'throws SQLException'으로 선언되어 있음
